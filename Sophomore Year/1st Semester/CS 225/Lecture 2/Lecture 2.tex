\documentclass{article}
\usepackage[left=2cm, right=2cm, top=1cm, bottom=1cm]{geometry}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{fancyhdr}

\title{CS 225: Lecture 2}
\author{Cliff Sun}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{conjecture}[theorem]{Conjecture}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{one minute paper}[theorem]{One Minute Paper}

\pagestyle{fancy}
\lhead{\textbf{\thepage}\ \ \nouppercase{\rightmark}}
\chead{CS 225: Lecture 2}
\rhead{Cliff Sun}

\begin{document}

\maketitle

\section*{Memory Management}

\subsection*{Types of Memory Storage}
\begin{itemize}
    \item \textbf{Stack} - Local Variable Storage. Exists only in the function or scope (for-loop, while-loop, etc.)
    \item \textbf{Heap} - Dynamic Storage. Persist until deleted, we must manually delete it. (\textbf{\underline{New}} variable). Example - int* bruh = new int[5]. 
\end{itemize}

\subsection*{Parameters}

\begin{itemize}
    \item Pass by \textbf{value} - local copy of the original. Stores it on the stack. (addID(ID id))
    \item Pass by \textbf{pointer} - a pointer address to the heap, function can directly edit the variable. This creates a new pointer to the original variable. (addID(ID* id))
    \item Pass by \textbf{reference} - pass the actual variable, function can edit this. No new pointer is being made. (addID(ID\& id))
\end{itemize}

\subsection*{Rule of Three}
In general, when defining variables and needing any of the bottom listed classes, it's suggested that you define all. 
\begin{enumerate}
    \item Destructor - Called when we need to delete object
    \item Copy Constructor - Make new object as a copy of the existing one
    \item Copy Assignment Operator - Copy variable X to new variable Y
\end{enumerate}

\end{document}